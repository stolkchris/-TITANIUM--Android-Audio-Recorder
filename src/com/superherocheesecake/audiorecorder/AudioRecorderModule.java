/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2013 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.superherocheesecake.audiorecorder;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.kroll.common.Log;

import android.content.Context;
import android.media.MediaRecorder;
import android.media.AudioRecord;
import android.media.AudioFormat;
import android.os.Environment;

@Kroll.module(name="AudioRecorder", id="com.superherocheesecake.audiorecorder")
public class AudioRecorderModule extends KrollModule
{

    private AudioRecord recorder     = null;
    private String      filename     = null;
    private String      filepath     = null;
    private String      fullFilePath = null;
    private Boolean     isRecording  = false;

    private KrollFunction successCallback = null;
    private KrollFunction errorCallback   = null;

    private String AUDIO_RECORDER_FOLDER = "audio_recorder";

    // Standard Debugging variables
    private static final String TAG = "AudioRecorderModule";

    // You can define constants with @Kroll.constant, for example:
    // @Kroll.constant public static final String EXTERNAL_NAME = value;
    
    public AudioRecorderModule()
    {
        super();
    }

    @Kroll.onAppCreate
    public static void onAppCreate(TiApplication app)
    {
        Log.d(TAG, "inside onAppCreate");
        // put module init code that needs to run when the application is created
    }


    // Methods
    @SuppressWarnings("deprecation")
    private KrollFunction getCallback(final KrollDict options, final String name) {
        return (KrollFunction) options.get(name);
    }

    /* Checks if external storage is available for read and write */
    public boolean isExternalStorageWritable() {
        String state = Environment.getExternalStorageState();
        if (Environment.MEDIA_MOUNTED.equals(state)) {
            return true;
        }
        return false;
    }

    /**
     * Sends success event and calls the success callback
     * @param filepath [description]
     */
    private void sendSuccessEvent(String filepath) {
        if (successCallback != null) {
            //System.out.println("@@## inside: successCallback");
            //System.out.println("@@## filepath: " + filepath);
            HashMap<String, String> event = new HashMap<String, String>();
            event.put("filePath", filepath);
            event.put("fileName", fullFilePath);

            // Fire an event directly to the specified listener (callback)
            successCallback.call(getKrollObject(), event);
        }
    }

    /**
     * Sends an error event and calls the error callback
     * @param message Error message
     */
    private void sendErrorEvent(String message) {
        //System.out.println("@@## inside: sendErrorEvent");
        //System.out.println("@@## message: " + message);
        if (errorCallback != null) {
            HashMap<String, String> event = new HashMap<String, String>();
            event.put("message", message);

            // Fire an event directly to the specified listener (callback)
            errorCallback.call(getKrollObject(), event);
        }
    }

    /**
     * Registers callbacks
     * @param args Arguments for callbacks
     */
    @Kroll.method
    public void registerCallbacks(HashMap args) {
        Object callback;

        // Save the callback functions, verifying that they are of the correct type
        if (args.containsKey("success")) {
            callback = args.get("success");
            if (callback instanceof KrollFunction) {
                successCallback = (KrollFunction) callback;
            }
        }

        if (args.containsKey("error")) {
            callback = args.get("error");
            if (callback instanceof KrollFunction) {
                errorCallback = (KrollFunction) callback;
            }
        }
    }

    private String getFilename(String selectedFileName, String selectedDirName, String location) {
        String directoryName = AUDIO_RECORDER_FOLDER;
        if (selectedDirName != null && selectedDirName.length() > 0) {
            directoryName = selectedDirName;
        }

        String fileName = System.currentTimeMillis() + "";
        if (selectedFileName != null && selectedFileName.length() > 0) {
            fileName = selectedFileName + ".wav";
        }

        filename = fileName;

        System.out.println("@@## cheking external storage: " + isExternalStorageWritable());
        if(location.equals("internal")){
            File audioDirectory = TiApplication.getAppRootOrCurrentActivity().getDir(directoryName, Context.MODE_WORLD_READABLE);
            //System.out.println("@@## audioDirectory.exists(): " + audioDirectory.exists());
            if (!audioDirectory.exists()) {
                audioDirectory.mkdirs();
            }
            fullFilePath = (audioDirectory.getAbsolutePath() + "/" + filename);
            //System.out.println("@@## internal fullFileName: " + fullFileName);
            return fullFilePath;
        } else {
            if(isExternalStorageWritable()){
                String packageName = TiApplication.getAppRootOrCurrentActivity().getPackageName();
                //System.out.println("@@## packageName: " + packageName);
                String sdCardPath = Environment.getExternalStorageDirectory().getPath();
                File audioDirectory = new File(sdCardPath, packageName+"/"+directoryName);

                if (!audioDirectory.exists()) {
                    audioDirectory.mkdirs();
                }

                fullFilePath = (audioDirectory.getAbsolutePath() + "/" + filename);
                //System.out.println("@@## external fullFileName: " + fullFileName);
                return fullFilePath;
            } else {
                return null;
            }
        }
    }

    @Kroll.method
    public void startRecording(HashMap args) {
        if(isRecording){
            sendErrorEvent("Another audio record is inprogress");
        } else {
            recorder          = null;
            KrollDict options = new KrollDict(args);
            
            String fileName      = (String) options.get("fileName");
            String fileDirectory = (String) options.get("directoryName");
            String fileLocation  = (options.containsKey("fileLocation")) ? (String) options.get("fileLocation") : "external";

            registerCallbacks(args);

            final String outputFileName = getFilename(fileName, fileDirectory, "external");
            //System.out.println("@@## outputFileName = "+outputFileName);
            if(outputFileName == null || outputFileName == ""){
                sendErrorEvent("External storage not available");
                return;
            }

            int audioFormat             = AudioFormat.ENCODING_PCM_16BIT;
            int sampleRate              = 44100;
            int channelConfig           = AudioFormat.CHANNEL_IN_MONO;
            final int bufferSizeInBytes = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat);
            final byte Data[]           = new byte[bufferSizeInBytes];
            
            recorder = new AudioRecord(
                MediaRecorder.AudioSource.MIC, 
                sampleRate,
                channelConfig,
                audioFormat,
                bufferSizeInBytes
            );

            try {
                Thread recordingThread = new Thread(new Runnable() {
                    public void run() {
                        // Create file output stream variable
                        FileOutputStream os = null;

                        try {
                            os = new FileOutputStream(outputFileName);
                        } catch (FileNotFoundException e) {
                            e.printStackTrace();
                        }
                        while(isRecording) {
                            recorder.read(Data, 0, Data.length);
                            try {
                                os.write(Data, 0, bufferSizeInBytes);
                            } catch (IOException e) {
                                e.printStackTrace();
                                sendErrorEvent(e.toString());
                            }
                            try {
                                os.close();
                            } catch (IOException e) {
                                e.printStackTrace();
                                sendErrorEvent(e.toString());
                            }
                        }
                    }
                });
                recordingThread.start();
                recorder.startRecording();
            } catch (Exception e) {
                isRecording = false;
                recorder.stop();

                e.printStackTrace();
                sendErrorEvent(e.toString());
            }
        }
    }

    @Kroll.method
    public void stopRecording() {
        //System.out.println("@@## called: stopRecording");
        if (null != recorder) {
            try {
                recorder.stop();
                recorder.release();

                recorder    = null;
                isRecording = false;
                sendSuccessEvent(fullFilePath);
            } catch (IllegalStateException e) {
                //System.out.println("@@## Error2 IllegalStateException e = "+e);
                e.printStackTrace();
                sendErrorEvent(e.toString());
            }
        }
    }

    @Kroll.method
    public Boolean isRecording() {
        return isRecording;
    }

}

